    async def create_mcp_request(self, mcp_request: MCPTaskRequest):
        task = mcp_request.task
        mcp_server = task.mcp_server
        plan = mcp_request.plan.context.conversations
        mcp_tools = self.mcp_tools_dict[mcp_server]
        client_url = os.environ.get("CLIENT_URL", "")
        
        system_prompt = MCP_REQUEST_SYSTEM_PROMPT.format(
            mcp_server_speciality=self.server_descriptions_dict[mcp_server]
        )
        background_information = self.prepare_background_information(mcp_request.plan, mcp_request.task.step_number)
        
        user_prompt = MCP_REQUEST_PROMPT.format(
            plan_name=mcp_request.plan.plan_name,
            plan_overview=mcp_request.plan.plan_overview,
            background_information=background_information,
            task=mcp_request.task.task_name,
            reason=mcp_request.task.task_explanation,
            expectation=mcp_request.task.expected_result
        )
        
        tools = self.openai_client.chat.completions.create(
            model="deepseek-chat",
            messages=[{"role": "system", "content": system_prompt}, {"role": "user", "content": user_prompt}],
            tools=mcp_tools,
            tool_choice="required"
        )
        
        # Parse the tools response into ToolCallInfo objects
        tool_calls = parse_mcp_tools(tools, mcp_server, self.mcp_tools_dict)
        task_id = mcp_request.task.id
        
        # Convert tool_calls to a format suitable for the database
        try:
            # For Pydantic v2
            skills_data = [tool_call.model_dump() for tool_call in tool_calls]
        except AttributeError:
            # Fallback for Pydantic v1
            skills_data = [tool_call.dict() for tool_call in tool_calls]
        
        # Update the task with the skills information
        async with httpx.AsyncClient() as client:
            try:
                # First update the task with the skills information
                update_url = f"{client_url}/api/plan/update_task"
                
                # Ensure the data is properly serializable by using json.dumps/loads
                # This ensures we have valid JSON that PostgreSQL can accept
                json_string = json.dumps(skills_data)
                validated_json = json.loads(json_string)
                
                update_payload = {
                    "id": task_id,
                    "skills": validated_json,
                    "status": "pending"  # Optionally update status
                }
                
                update_response = await client.put(
                    update_url,
                    json=update_payload,
                    headers={"Content-Type": "application/json"}
                )
                update_response.raise_for_status()
                
                # Then continue with your existing code to fetch messages
                response = await client.post(
                    f"{client_url}/api/chat/get_messages", 
                    json={"roomId": mcp_request.plan.room_id, "limit": 100},
                    headers={"Content-Type": "application/json"}
                )
                response.raise_for_status()
                messages = response.json()
                
                await self.socket_client.send_notification(
                    {
                        "id": str(uuid4()),
                        "notification_id": str(uuid4()),
                        "room_id": mcp_request.plan.room_id,
                        "message": f"Task {task_id} has been created",
                        "sender": mcp_request.plan.assignee,
                        "created_at": datetime.datetime.now(datetime.timezone(datetime.timedelta(hours=8))).isoformat(),
                        "updating_plan": mcp_request.plan.id
                    }
                )
            except Exception as e:
                logger.error(f"Error updating task or fetching messages: {e}")
                if isinstance(e, httpx.HTTPStatusError):
                    logger.error(f"Response content: {e.response.content}")
                messages = []

    async def execute_mcp_request(self, mcp_request: MCPTaskRequest):
        task = mcp_request.task
        plan_size = len(mcp_request.plan.context.plan["plan"])
        step_number = task.step_number
        skills = task.skills
        session = self.servers[task.mcp_server]
        logger.info(f"Plan size: {plan_size}")
        client_url = os.environ.get("CLIENT_URL", "")
        
        results = {}
        tool_call_ct = defaultdict(int)
        for skill in skills:
            resp = None
            skill_name = skill['tool_name']
            try:
                args = skill['args']
                args = {k: arg["value"] for k, arg in args.items()}
                resp = await session.call_tool(skill_name, args)
            except Exception as e:
                logger.error(f"Error calling skill {skill_name}: {e}")
                continue
            results[f"{skill_name}_{tool_call_ct[skill_name]}"] = resp.content[0].text
            tool_call_ct[skill_name] += 1
        
        # update the task with logs and change status to success
        async with httpx.AsyncClient() as client:
            try:
                update_url = f"{client_url}/api/plan/update_task"
                response = await client.put(
                    update_url,
                    json={
                        "id": task.id,  # Use id instead of task_id
                        "status": "success",
                        "logs": results,
                        "step_number": step_number
                    }
                )
                response.raise_for_status()
                logger.info(f"Successfully updated task {task.id} with logs")
                
                # Create task_completed log using the create_plan_log API
                log_response = await client.post(
                    f"{client_url}/api/plan/create_plan_log",
                    json={
                        "type": "task_completed",
                        "plan_id": mcp_request.plan.id,
                        "task_id": task.id,  # Use id instead of task_id
                        "content": f"Task **{task.task_name}** has been completed"
                    },
                    headers={"Content-Type": "application/json"}
                )
                log_response.raise_for_status()
                logger.info(f"Successfully created task_completed log")
            except Exception as e:
                logger.error(f"Error updating task with logs or creating log: {e}")
                if isinstance(e, httpx.HTTPStatusError):
                    logger.error(f"Response content: {e.response.content}")
        
        async with httpx.AsyncClient() as client:
            try:
                update_url = f"{client_url}/api/plan/update_plan"
                plan_status = "running" if step_number < plan_size else "success"
                response = await client.put(
                    update_url,
                    json={
                        "id": mcp_request.plan.id,  # Changed from plan_id to id
                        "status": plan_status,
                        "progress": int((step_number / plan_size) * 100),
                        "logs": results,
                        "step_number": step_number
                    }
                )
                
                # If plan is completed, create plan_completed log
                if plan_status == "success":
                    log_response = await client.post(
                        f"{client_url}/api/plan/create_plan_log",
                        json={
                            "type": "plan_completed",
                            "plan_id": mcp_request.plan.id,  # Changed from plan_id to id
                            "content": f"Plan **{mcp_request.plan.plan_name}** has been completed"
                        },
                        headers={"Content-Type": "application/json"}
                    )
                    log_response.raise_for_status()
                    logger.info(f"Successfully created plan_completed log")
            except Exception as e:
                logger.error(f"Error updating plan status or creating log: {e}")
        
        await self.socket_client.send_notification(
            {
                "id": str(uuid4()),
                "notification_id": str(uuid4()),
                "room_id": mcp_request.plan.room_id,
                "message": f"Task {task.id} has been executed",
                "sender": mcp_request.plan.assignee,
                "created_at": datetime.datetime.now(datetime.timezone(datetime.timedelta(hours=8))).isoformat(),
                "updating_plan": mcp_request.plan.id
            }
        )


    async def check_and_update_plan_status(self, plan_id: str) -> None:
        """
        Check if all tasks for a plan are completed and update the plan status accordingly.
        
        Args:
            plan_id: The ID of the plan to check
        """
        client_url = os.environ.get("CLIENT_URL", "")
        try:
            async with httpx.AsyncClient() as client:
                # Get all tasks for this plan
                response = await client.get(
                    f"{client_url}/api/plan/get_tasks?plan_id={plan_id}",
                    headers={"Content-Type": "application/json"}
                )
                response.raise_for_status()
                tasks_data = response.json()
                
                # Check if all tasks are completed
                tasks = tasks_data.get("tasks", [])
                if not tasks:
                    return
                    
                all_completed = all(task.get("status") in ["success", "failed"] for task in tasks)
                all_successful = all(task.get("status") == "success" for task in tasks)
                
                if all_completed:
                    # Calculate progress as percentage of successful tasks
                    successful_tasks = sum(1 for task in tasks if task.get("status") == "success")
                    progress = int((successful_tasks / len(tasks)) * 100)
                    
                    # Update plan status
                    status = "success" if all_successful else "failed"
                    await client.put(
                        f"{client_url}/api/plan/update_plan",
                        json={
                            "id": plan_id,
                            "status": status,
                            "progress": progress,
                            "completed_at": datetime.datetime.now(datetime.timezone(datetime.timedelta(hours=8))).isoformat()
                        },
                        headers={"Content-Type": "application/json"}
                    )
                    
                    # Create plan status log using the create_plan_log API
                    log_type = "plan_completed" if status == "success" else "plan_failed"
                    log_content = f"Plan has been {status}"
                    await client.post(
                        f"{client_url}/api/plan/create_plan_log",
                        json={
                            "type": log_type,
                            "plan_id": plan_id,
                            "content": log_content
                        },
                        headers={"Content-Type": "application/json"}
                    )
                    
                    logger.info(f"Updated plan {plan_id} status to {status} with progress {progress}%")
        except Exception as e:
            logger.error(f"Error checking and updating plan status: {e}")
